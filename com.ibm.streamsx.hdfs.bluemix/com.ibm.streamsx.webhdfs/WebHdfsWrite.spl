namespace com.ibm.streamsx.webhdfs;
use com.ibm.streamsx.inet.http::httpPost;
use com.ibm.streamsx.inet.http::httpPut;

/*
 * Used internally to find the header that starts with
 * "Location:", used to both create and append.
 */
rstring getLocation(list<rstring> headers) {
		rstring locationHeader = "Location: ";
		rstring locationPattern ="^"+locationHeader;
		int32 locationSize = length(locationHeader);
		for (rstring l in headers) {
			if (size(regexMatch(l,locationPattern)) > 0) {
				rstring location = rtrim(substring(l,locationSize,length(l)-locationSize),"\n\r");
				return location;
			}
		}
		return "";
}


/**
 * Write data to WebHdfs
 * 
 * Formats the tuple with Format, and then sends the blob to WebHdfsWriteBinary.
 * If consistent cut is enabled, the same tuple could be sent to the file multiple times;
 * this could result in an corrupted file if the Format parameter is block.
 * 
 * @input Stream to write to WebHdfs
 * @param url to access webhdfs.  It should start with http://host:port/..webhdfs/v1
 * @param file filename to write
 * @param username username to use to connector to webhdfs if accessed via a knox gateway
 * @param password password to use to connect ot webhdfs if accessed via a knox gateway
 * @param overwrite true if hte file should be overwritten if present, false otherwise
 * @format format parameter to be passed to Format operator; defaults to line.
 */
public composite WebHdfsWrite (input InStream) {

param 
expression<rstring> $url;
expression<rstring> $file;
expression<rstring> $username:"";
expression<rstring> $password:"";
expression<boolean> $overwrite: false;

expression $format: Format.line;
graph

stream<blob data> Blobs = Format(InStream) {
	param
	format: $format;
	output Blobs: data =Output();
}

() as sink = WebHdfsWriteBinary(Blobs) {
	param
		baseUrl: $url;
		file: $file;
		username: $username;
		password: $password;
		overwrite: $overwrite;
}

}


/**
 * Used by WebHdfsWrite; the only case you should consider 
 * using this is if your data is binary blobs so that you don't
 * want a format operator.  See WebHdfsWrite for parameter
 * descriptions.  
 */
public composite WebHdfsWriteBinary (input InStream) {
param 
expression<rstring> $baseUrl;
expression<rstring> $file;
expression<rstring> $username: "";
expression<rstring> $password: "";
expression<boolean> $overwrite: false;


graph 
() as writer = Custom(InStream) {
	logic state: {
		rstring createUrl = $baseUrl+"/"+$file+"?op=CREATE&overwrite="+(rstring)$overwrite;
		rstring appendUrl = $baseUrl+"/"+$file+"?op=APPEND";
		rstring username = $username;
		rstring password = $password;
		mutable boolean needToCreate = true;
		rstring emptyString = "";
		mutable rstring appendLocation = "";
		list<rstring> postExtraHeaders=["Content-Type:"];
	}
	
	onTuple InStream: {
		mutable list<rstring> headers = (list<rstring>)[];
		// This is the first time we've seen a tuple for this file,
		// lets create it.
		if (needToCreate) {
			mutable int32 error = 0;
			appTrc(Trace.info, "Processing first tuple");
			rstring newFile= httpPut(emptyString,createUrl,(list<rstring>)[],username,password,headers,error);
			if (error != 0 || length(newFile) > 0) {
				abort();
			}
			rstring location = getLocation(headers);
			if (length(location) == 0) {
				appTrc(Trace.error,"Unable to get locations from headers");
				abort();
			}

			rstring exception = httpPut(convertFromBlob(data),location,(list<rstring>)[],username,password,headers,error);
			if (error != 0) {
				abort();
			}
			if (length(exception) > 0) {
				appTrc(Trace.error,"Unexpected response from server: "+exception);
				abort();
			}
			needToCreate = false;
		}
		else {
			mutable int32 error = 0;
			if (appendLocation == "") {
				appTrc(Trace.info,"First append operation");
				rstring locationReturn = httpPost(emptyString,appendUrl,postExtraHeaders,username,password,headers, error);
				appendLocation = getLocation(headers);
				if(error != 0 || length(locationReturn) > 0 || length(appendLocation)==0) {
					abort();
				}
			}
			rstring postDataReturn = httpPost(convertFromBlob(data),appendLocation,postExtraHeaders,username,password,headers,error);
			if (error != 0 || length(postDataReturn) >0) {
				appTrc(Trace.error,"error code: "+(rstring)error+" Unexpected response from server: "+postDataReturn);
				abort();
			}
		}
	}

}

}
