namespace com.ibm.streamsx.webhdfs;
use com.ibm.streamsx.inet.http::httpGet;

rstring getValue(rstring string, rstring pattern, int32 startPos) {
    int32 valueStart = findFirst(string,pattern,startPos);
    if (valueStart < 0) {
        appTrc(Trace.error,"Error finding pattern "+pattern+" in string "+string+" from "+(rstring)startPos);
    }
    int32 endPos = findFirstOf(string,"\",",valueStart+length(pattern));
    return substring(string,valueStart+length(pattern),endPos - valueStart - length(pattern));
}

/** Scan a HDFS directory using WebHdfs.
 *
 * Periodically scans the directory and sends the filename of new 
 * or updated files.  This composite consists of two primitive operators
 * that will always be fused into the same PE.  
 * 
 * For best results, use a config placement: partitionColocation()
 * statement in your invocation.
 * @param url Base url to access webhdfs "https://host:port/.../webhdfs/v1";
 * @param username (optional) username to use
 * @param password (optional) password to use
 * @param directory directory to scan.
 * @param period how often to scan the directory.
 * @param initDelay (optional) how long to wait before the first scan.
 */

public composite WebHdfsDirectoryScan(output stream<rstring filename> Filenames) {

    param 
        expression<rstring> $url;
    expression<rstring> $username: "";
    expression<rstring> $password: "";
    expression<rstring> $directory: "";
    expression<float64> $period: 60.0;
    expression<float64> $initDelay: 0.0;

    graph

        // We use a Beacon to start this so that it is 
        // consistent cut friendly.
        // Consistent cut doesn't work with a onProcess in a Custom as of this
        // moment (Oct 2015), so instead we start with a beacon and then do the work in 
        // the onTuple.
        stream<int32 anInt> Trigger = Beacon() {
            param period: $period;
initDelay: $initDelay;
           output Trigger:
               anInt = (int32)IterationCount();
           config placement: partitionColocation(getThisCompositeInstanceName());
        }


    stream<rstring filename> Filenames = Custom(Trigger) {
        logic state: {
            rstring url= $url+"/"+$directory+"?op=LISTSTATUS";
            list<rstring> extraHeaders = ["Accept: application/json"];
            mutable map<rstring,rstring> nameToAccess = {};
        }
        onTuple Trigger: {
            mutable int32 error = 0;
            rstring jsonList = httpGet(url,extraHeaders,$username,$password,error);
            if (error != 0) {
                appTrc(Trace.error, "Error code "+(rstring)error+" from httpGet, returned result was "+jsonList);
                abort();
            }
            mutable int32 itemStart = findFirst(jsonList,"[");
            while (itemStart > 0) {
                rstring itemType = getValue(jsonList,"type\":\"",itemStart);
                if (itemType == "FILE") {
                    rstring itemTime = getValue(jsonList,"\"modificationTime\":",itemStart);
                    rstring filename = getValue(jsonList,"\"pathSuffix\":\"",itemStart);
                    appTrc(Trace.info, "File is "+filename+" with time "+itemTime+" and type "+itemType);
                    if (!has(nameToAccess,filename) || nameToAccess[filename] < itemTime) {
                           nameToAccess[filename] = itemTime;
                           submit({filename=filename},Filenames);
                    }
                }
                int32 endItem = findFirst(jsonList,"}",itemStart);
                itemStart = findFirst(jsonList,"{",endItem);
            }
            submit(Sys.WindowMarker,Filenames);

        }
        config placement: partitionColocation(getThisCompositeInstanceName());
    }
}
