namespace com.ibm.streamsx.webhdfs;

/**
  * WebHdfsRead -- Read a file from HDFS via the REST APIs
  * 
  * All operators in this composite will be fused into a single PE.
  *
  * @param url The base url, should end with http://.../webhdfs/v1
  * @param file the file to be read
  * @username username to connect (optional)
  * @password password to use to connect (optional)
  * @param format format to use for the parse operator.  Defaults to Parse.line
  * @param blockSize size of block to get per http call.  (optional)
  * @param OutType the type of the output stream.
  * @param partition (optional) partition colocation id to use.  Use this if you're doing higher-level fusion in your application.
  */

public composite WebHdfsRead(output OutStream) {

    param 
        expression<rstring> $url;
    expression<rstring> $username:"";
    expression<rstring> $password:"";
    expression<rstring> $file;
    expression $format: Parse.line;
    expression $blockSize: 16384u;
    type $OutType: tuple<rstring line>;
    expression<rstring> $partition: getThisCompositeInstanceName();

    graph 

    stream<rstring filename> Files = Beacon() {
    param iterations: 1;
    output Files: 
        filename= $file;
    config placement: partitionColocation($partition);
    }

    stream<$OutType> OutStream = WebHdfsReadFiles(Files) {
        param
            url:$url;
username:$username;
password:$password;
format: $format;
blockSize: $blockSize;
OutType:$OutType;
partition: $partition;
        config placement: partitionColocation($partition);
    }

}

/** WebHdfsReadFiles -- Read files given on an input stream from HDFS via the REST APIs
  *
  * All operators in this composite will be fused into the same PE.
  * 
  * @param url The base url, should end with http://.../webhdfs/v1
  * @param username username to use to connect, if empty, it's ignored
  * @param password password to use to connect, optional.
  * @param format format to use for parse operator.  Defaults to Parse.line
  * @param blockSize size of block to get per http call.  
  * @param OutType the type of output stream.
  * @param partition (optional) the name of the partition to use in the partitionColocation statement
  */

public composite WebHdfsReadFiles(input stream<rstring filename> FilenameStream;output OutStream ) {
    param
        expression<rstring> $url;
    expression<rstring> $username;
    expression<rstring> $password;
    expression $format: Parse.line;
    expression<uint32> $blockSize: 16384u;
    type $OutType: tuple<rstring line>;
    expression<rstring> $partition:getThisCompositeInstanceName();

    graph
        stream<blob block> Blocks = WebHdfsReadBinaryFiles(FilenameStream) {
            param
                baseUrl: $url;
                username: $username;
                password: $password;
                blockSize: $blockSize;
           config placement: partitionColocation($partition);
        }

    stream<$OutType> OutStream = Parse(Blocks) {
        param format: $format;
        config placement: partitionColocation($partition);
    }

}

/** Read binary data from a webhdfs file.
  * 
  * Except in the case where the file is binary, you should use WebHdfsRead
  */

public composite WebHdfsReadBinaryFiles(input stream<rstring filename> FilenameStream; output Blocks) {

    param 
        expression<rstring> $baseUrl;
    expression<rstring> $username;
    expression<rstring> $password;
    expression<uint32> $blockSize: 16384u;
    graph 

        stream<blob block> Blocks = Custom(FilenameStream) {

            logic state: {
                // If they are submission time values, this way we only compute them once.
                rstring username = $username;
                rstring password = $password;
                rstring lengthSection = "&length="+(rstring)$blockSize;
                int32 blockSize = (int32)$blockSize;
            }
            onTuple FilenameStream: {
               rstring url = $baseUrl+"/"+filename+"?OP=OPEN";
               mutable int32 error = 0;
               mutable boolean done = false;
               mutable int64 offset = 0;
               while (!done) {
                   rstring blockUrl = url+"&offset="+(rstring)offset+lengthSection;
                   rstring result = com.ibm.streamsx.inet.http::httpGet(blockUrl,(list<rstring>)[],username,password,error);
                   if (error != 0) {
                       abort();
                   }
                   if (length(result) == 0) {
                       // Nothing elft, mark done, and don't submit.
                       done = true;
                   }
                   else {
                       // we have something to submit.
                       submit({block=convertToBlob(result)},Blocks);
                       if (length(result) < blockSize) {
                           // no more left, say we're done
                           done =true;
                       }
                   }
                   offset += (int64)length(result);
               }
               submit(Sys.WindowMarker,Blocks);
           }
           onPunct FilenameStream: {
            if (currentPunct() == Sys.FinalMarker) {
                submit(currentPunct(),Blocks);
            }
           }
        }
}
